/* automatically generated - do not edit. */
#include <string>
static const std::string k_descriptor_proto_content =
  "// Protocol Buffers - Google's data interchange format\n"
  "// Copyright 2008 Google Inc.  All rights reserved.\n"
  "// http://code.google.com/p/protobuf/\n"
  "//\n"
  "// Redistribution and use in source and binary forms, with or without\n"
  "// modification, are permitted provided that the following conditions are\n"
  "// met:\n"
  "//\n"
  "//     * Redistributions of source code must retain the above copyright\n"
  "// notice, this list of conditions and the following disclaimer.\n"
  "//     * Redistributions in binary form must reproduce the above\n"
  "// copyright notice, this list of conditions and the following disclaimer\n"
  "// in the documentation and/or other materials provided with the\n"
  "// distribution.\n"
  "//     * Neither the name of Google Inc. nor the names of its\n"
  "// contributors may be used to endorse or promote products derived from\n"
  "// this software without specific prior written permission.\n"
  "//\n"
  "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
  "// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
  "// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
  "// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
  "// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
  "// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
  "// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
  "// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
  "// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
  "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
  "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  "\n"
  "// Author: kenton@google.com (Kenton Varda)\n"
  "//  Based on original Protocol Buffers design by\n"
  "//  Sanjay Ghemawat, Jeff Dean, and others.\n"
  "//\n"
  "// The messages in this file describe the definitions found in .proto files.\n"
  "// A valid .proto file can be translated directly to a FileDescriptorProto\n"
  "// without any other information (e.g. without reading its imports).\n"
  "\n"
  "\n"
  "\n"
  "package google.protobuf;\n"
  "option java_package = \"com.google.protobuf\";\n"
  "option java_outer_classname = \"DescriptorProtos\";\n"
  "\n"
  "// descriptor.proto must be optimized for speed because reflection-based\n"
  "// algorithms don't work during bootstrapping.\n"
  "option optimize_for = SPEED;\n"
  "\n"
  "// The protocol compiler can output a FileDescriptorSet containing the .proto\n"
  "// files it parses.\n"
  "message FileDescriptorSet {\n"
  "  repeated FileDescriptorProto file = 1;\n"
  "}\n"
  "\n"
  "// Describes a complete .proto file.\n"
  "message FileDescriptorProto {\n"
  "  optional string name = 1;       // file name, relative to root of source tree\n"
  "  optional string package = 2;    // e.g. \"foo\", \"foo.bar\", etc.\n"
  "\n"
  "  // Names of files imported by this file.\n"
  "  repeated string dependency = 3;\n"
  "\n"
  "  // All top-level definitions in this file.\n"
  "  repeated DescriptorProto message_type = 4;\n"
  "  repeated EnumDescriptorProto enum_type = 5;\n"
  "  repeated ServiceDescriptorProto service = 6;\n"
  "  repeated FieldDescriptorProto extension = 7;\n"
  "\n"
  "  optional FileOptions options = 8;\n"
  "}\n"
  "\n"
  "// Describes a message type.\n"
  "message DescriptorProto {\n"
  "  optional string name = 1;\n"
  "\n"
  "  repeated FieldDescriptorProto field = 2;\n"
  "  repeated FieldDescriptorProto extension = 6;\n"
  "\n"
  "  repeated DescriptorProto nested_type = 3;\n"
  "  repeated EnumDescriptorProto enum_type = 4;\n"
  "\n"
  "  message ExtensionRange {\n"
  "    optional int32 start = 1;\n"
  "    optional int32 end = 2;\n"
  "  }\n"
  "  repeated ExtensionRange extension_range = 5;\n"
  "\n"
  "  optional MessageOptions options = 7;\n"
  "}\n"
  "\n"
  "// Describes a field within a message.\n"
  "message FieldDescriptorProto {\n"
  "  enum Type {\n"
  "    // 0 is reserved for errors.\n"
  "    // Order is weird for historical reasons.\n"
  "    TYPE_DOUBLE         = 1;\n"
  "    TYPE_FLOAT          = 2;\n"
  "    TYPE_INT64          = 3;   // Not ZigZag encoded.  Negative numbers\n"
  "                               // take 10 bytes.  Use TYPE_SINT64 if negative\n"
  "                               // values are likely.\n"
  "    TYPE_UINT64         = 4;\n"
  "    TYPE_INT32          = 5;   // Not ZigZag encoded.  Negative numbers\n"
  "                               // take 10 bytes.  Use TYPE_SINT32 if negative\n"
  "                               // values are likely.\n"
  "    TYPE_FIXED64        = 6;\n"
  "    TYPE_FIXED32        = 7;\n"
  "    TYPE_BOOL           = 8;\n"
  "    TYPE_STRING         = 9;\n"
  "    TYPE_GROUP          = 10;  // Tag-delimited aggregate.\n"
  "    TYPE_MESSAGE        = 11;  // Length-delimited aggregate.\n"
  "\n"
  "    // New in version 2.\n"
  "    TYPE_BYTES          = 12;\n"
  "    TYPE_UINT32         = 13;\n"
  "    TYPE_ENUM           = 14;\n"
  "    TYPE_SFIXED32       = 15;\n"
  "    TYPE_SFIXED64       = 16;\n"
  "    TYPE_SINT32         = 17;  // Uses ZigZag encoding.\n"
  "    TYPE_SINT64         = 18;  // Uses ZigZag encoding.\n"
  "  };\n"
  "\n"
  "  enum Label {\n"
  "    // 0 is reserved for errors\n"
  "    LABEL_OPTIONAL      = 1;\n"
  "    LABEL_REQUIRED      = 2;\n"
  "    LABEL_REPEATED      = 3;\n"
  "    // TODO(sanjay): Should we add LABEL_MAP?\n"
  "  };\n"
  "\n"
  "  optional string name = 1;\n"
  "  optional int32 number = 3;\n"
  "  optional Label label = 4;\n"
  "\n"
  "  // If type_name is set, this need not be set.  If both this and type_name\n"
  "  // are set, this must be either TYPE_ENUM or TYPE_MESSAGE.\n"
  "  optional Type type = 5;\n"
  "\n"
  "  // For message and enum types, this is the name of the type.  If the name\n"
  "  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping\n"
  "  // rules are used to find the type (i.e. first the nested types within this\n"
  "  // message are searched, then within the parent, on up to the root\n"
  "  // namespace).\n"
  "  optional string type_name = 6;\n"
  "\n"
  "  // For extensions, this is the name of the type being extended.  It is\n"
  "  // resolved in the same manner as type_name.\n"
  "  optional string extendee = 2;\n"
  "\n"
  "  // For numeric types, contains the original text representation of the value.\n"
  "  // For booleans, \"true\" or \"false\".\n"
  "  // For strings, contains the default text contents (not escaped in any way).\n"
  "  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.\n"
  "  // TODO(kenton):  Base-64 encode?\n"
  "  optional string default_value = 7;\n"
  "\n"
  "  optional FieldOptions options = 8;\n"
  "}\n"
  "\n"
  "// Describes an enum type.\n"
  "message EnumDescriptorProto {\n"
  "  optional string name = 1;\n"
  "\n"
  "  repeated EnumValueDescriptorProto value = 2;\n"
  "\n"
  "  optional EnumOptions options = 3;\n"
  "}\n"
  "\n"
  "// Describes a value within an enum.\n"
  "message EnumValueDescriptorProto {\n"
  "  optional string name = 1;\n"
  "  optional int32 number = 2;\n"
  "\n"
  "  optional EnumValueOptions options = 3;\n"
  "}\n"
  "\n"
  "// Describes a service.\n"
  "message ServiceDescriptorProto {\n"
  "  optional string name = 1;\n"
  "  repeated MethodDescriptorProto method = 2;\n"
  "\n"
  "  optional ServiceOptions options = 3;\n"
  "}\n"
  "\n"
  "// Describes a method of a service.\n"
  "message MethodDescriptorProto {\n"
  "  optional string name = 1;\n"
  "\n"
  "  // Input and output type names.  These are resolved in the same way as\n"
  "  // FieldDescriptorProto.type_name, but must refer to a message type.\n"
  "  optional string input_type = 2;\n"
  "  optional string output_type = 3;\n"
  "\n"
  "  optional MethodOptions options = 4;\n"
  "}\n"
  "\n"
  "// ===================================================================\n"
  "// Options\n"
  "\n"
  "// Each of the definitions above may have \"options\" attached.  These are\n"
  "// just annotations which may cause code to be generated slightly differently\n"
  "// or may contain hints for code that manipulates protocol messages.\n"
  "//\n"
  "// Clients may define custom options as extensions of the *Options messages.\n"
  "// These extensions may not yet be known at parsing time, so the parser cannot\n"
  "// store the values in them.  Instead it stores them in a field in the *Options\n"
  "// message called uninterpreted_option. This field must have the same name\n"
  "// across all *Options messages. We then use this field to populate the\n"
  "// extensions when we build a descriptor, at which point all protos have been\n"
  "// parsed and so all extensions are known.\n"
  "//\n"
  "// Extension numbers for custom options may be chosen as follows:\n"
  "// * For options which will only be used within a single application or\n"
  "//   organization, or for experimental options, use field numbers 50000\n"
  "//   through 99999.  It is up to you to ensure that you do not use the\n"
  "//   same number for multiple options.\n"
  "// * For options which will be published and used publicly by multiple\n"
  "//   independent entities, e-mail kenton@google.com to reserve extension\n"
  "//   numbers.  Simply tell me how many you need and I'll send you back a\n"
  "//   set of numbers to use -- there's no need to explain how you intend to\n"
  "//   use them.  If this turns out to be popular, a web service will be set up\n"
  "//   to automatically assign option numbers.\n"
  "\n"
  "\n"
  "message FileOptions {\n"
  "  option metadata_only = true;\n"
  "\n"
  "  // Sets the Java package where classes generated from this .proto will be\n"
  "  // placed.  By default, the proto package is used, but this is often\n"
  "  // inappropriate because proto packages do not normally start with backwards\n"
  "  // domain names.\n"
  "  optional string java_package = 1;\n"
  "\n"
  "\n"
  "  // If set, all the classes from the .proto file are wrapped in a single\n"
  "  // outer class with the given name.  This applies to both Proto1\n"
  "  // (equivalent to the old \"--one_java_file\" option) and Proto2 (where\n"
  "  // a .proto always translates to a single class, but you may want to\n"
  "  // explicitly choose the class name).\n"
  "  optional string java_outer_classname = 8;\n"
  "\n"
  "  // If set true, then the Java code generator will generate a separate .java\n"
  "  // file for each top-level message, enum, and service defined in the .proto\n"
  "  // file.  Thus, these types will *not* be nested inside the outer class\n"
  "  // named by java_outer_classname.  However, the outer class will still be\n"
  "  // generated to contain the file's getDescriptor() method as well as any\n"
  "  // top-level extensions defined in the file.\n"
  "  optional bool java_multiple_files = 10 [default=false];\n"
  "\n"
  "  // Generated classes can be optimized for speed or code size.\n"
  "  enum OptimizeMode {\n"
  "    SPEED = 1;        // Generate complete code for parsing, serialization,\n"
  "                      // etc.\n"
  "    CODE_SIZE = 2;    // Use ReflectionOps to implement these methods.\n"
  "    LITE_RUNTIME = 3; // Generate code using MessageLite and the lite runtime.\n"
  "  }\n"
  "  optional OptimizeMode optimize_for = 9 [default=SPEED];\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "  // Should generic services be generated in each language?  \"Generic\" services\n"
  "  // are not specific to any particular RPC system.  They are generated by the\n"
  "  // main code generators in each language (without additional plugins).\n"
  "  // Generic services were the only kind of service generation supported by\n"
  "  // early versions of proto2.\n"
  "  //\n"
  "  // Generic services are now considered deprecated in favor of using plugins\n"
  "  // that generate code specific to your particular RPC system.  If you are\n"
  "  // using such a plugin, set these to false.  In the future, we may change\n"
  "  // the default to false, so if you explicitly want generic services, you\n"
  "  // should explicitly set these to true.\n"
  "  optional bool cc_generic_services = 16 [default=true];\n"
  "  optional bool java_generic_services = 17 [default=true];\n"
  "  optional bool py_generic_services = 18 [default=true];\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message MessageOptions {\n"
  "  option metadata_only = true;\n"
  "  // Set true to use the old proto1 MessageSet wire format for extensions.\n"
  "  // This is provided for backwards-compatibility with the MessageSet wire\n"
  "  // format.  You should not use this for any other reason:  It's less\n"
  "  // efficient, has fewer features, and is more complicated.\n"
  "  //\n"
  "  // The message must be defined exactly as follows:\n"
  "  //   message Foo {\n"
  "  //     option message_set_wire_format = true;\n"
  "  //     extensions 4 to max;\n"
  "  //   }\n"
  "  // Note that the message cannot have any defined fields; MessageSets only\n"
  "  // have extensions.\n"
  "  //\n"
  "  // All extensions of your type must be singular messages; e.g. they cannot\n"
  "  // be int32s, enums, or repeated messages.\n"
  "  //\n"
  "  // Because this is an option, the above two restrictions are not enforced by\n"
  "  // the protocol compiler.\n"
  "  optional bool message_set_wire_format = 1 [default=false];\n"
  "\n"
  "  // Disables the generation of the standard \"descriptor()\" accessor, which can\n"
  "  // conflict with a field of the same name.  This is meant to make migration\n"
  "  // from proto1 easier; new code should avoid fields named \"descriptor\".\n"
  "  optional bool no_standard_descriptor_accessor = 2 [default=false];\n"
  "\n"
  "  // Tells whether a message is meant to be used by code generator only.\n"
  "  optional bool metadata_only = 3 [default=false];\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message FieldOptions {\n"
  "  option metadata_only = true;\n"
  "  // The ctype option instructs the C++ code generator to use a different\n"
  "  // representation of the field than it normally would.  See the specific\n"
  "  // options below.  This option is not yet implemented in the open source\n"
  "  // release -- sorry, we'll try to include it in a future version!\n"
  "  optional CType ctype = 1 [default = STRING];\n"
  "  enum CType {\n"
  "    // Default mode.\n"
  "    STRING = 0;\n"
  "\n"
  "    CORD = 1;\n"
  "\n"
  "    STRING_PIECE = 2;\n"
  "  }\n"
  "  // The packed option can be enabled for repeated primitive fields to enable\n"
  "  // a more efficient representation on the wire. Rather than repeatedly\n"
  "  // writing the tag and type for each element, the entire array is encoded as\n"
  "  // a single length-delimited blob.\n"
  "  optional bool packed = 2;\n"
  "\n"
  "\n"
  "  // Is this field deprecated?\n"
  "  // Depending on the target platform, this can emit Deprecated annotations\n"
  "  // for accessors, or it will be completely ignored; in the very least, this\n"
  "  // is a formalization for deprecating fields.\n"
  "  optional bool deprecated = 3 [default=false];\n"
  "\n"
  "  // EXPERIMENTAL.  DO NOT USE.\n"
  "  // For \"map\" fields, the name of the field in the enclosed type that\n"
  "  // is the key for this map.  For example, suppose we have:\n"
  "  //   message Item {\n"
  "  //     required string name = 1;\n"
  "  //     required string value = 2;\n"
  "  //   }\n"
  "  //   message Config {\n"
  "  //     repeated Item items = 1 [experimental_map_key=\"name\"];\n"
  "  //   }\n"
  "  // In this situation, the map key for Item will be set to \"name\".\n"
  "  // TODO: Fully-implement this, then remove the \"experimental_\" prefix.\n"
  "  optional string experimental_map_key = 9;\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message EnumOptions {\n"
  "  option metadata_only = true;\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message EnumValueOptions {\n"
  "  option metadata_only = true;\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message ServiceOptions {\n"
  "  option metadata_only = true;\n"
  "\n"
  "  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n"
  "  //   framework.  We apologize for hoarding these numbers to ourselves, but\n"
  "  //   we were already using them long before we decided to release Protocol\n"
  "  //   Buffers.\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "message MethodOptions {\n"
  "  option metadata_only = true;\n"
  "\n"
  "  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC\n"
  "  //   framework.  We apologize for hoarding these numbers to ourselves, but\n"
  "  //   we were already using them long before we decided to release Protocol\n"
  "  //   Buffers.\n"
  "\n"
  "  // The parser stores options it doesn't recognize here. See above.\n"
  "  repeated UninterpretedOption uninterpreted_option = 999;\n"
  "\n"
  "  // Clients can define custom options in extensions of this message. See above.\n"
  "  extensions 1000 to max;\n"
  "}\n"
  "\n"
  "// A message representing a option the parser does not recognize. This only\n"
  "// appears in options protos created by the compiler::Parser class.\n"
  "// DescriptorPool resolves these when building Descriptor objects. Therefore,\n"
  "// options protos in descriptor objects (e.g. returned by Descriptor::options(),\n"
  "// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions\n"
  "// in them.\n"
  "message UninterpretedOption {\n"
  "  option metadata_only = true;\n"
  "  // The name of the uninterpreted option.  Each string represents a segment in\n"
  "  // a dot-separated name.  is_extension is true iff a segment represents an\n"
  "  // extension (denoted with parentheses in options specs in .proto files).\n"
  "  // E.g.,{ [\"foo\", false], [\"bar.baz\", true], [\"qux\", false] } represents\n"
  "  // \"foo.(bar.baz).qux\".\n"
  "  message NamePart {\n"
  "    required string name_part = 1;\n"
  "    required bool is_extension = 2;\n"
  "  }\n"
  "  repeated NamePart name = 2;\n"
  "\n"
  "  // The value of the uninterpreted option, in whatever type the tokenizer\n"
  "  // identified it as during parsing. Exactly one of these should be set.\n"
  "  optional string identifier_value = 3;\n"
  "  optional uint64 positive_int_value = 4;\n"
  "  optional int64 negative_int_value = 5;\n"
  "  optional double double_value = 6;\n"
  "  optional bytes string_value = 7;\n"
  "}\n"
  "";
